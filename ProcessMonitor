using System;
using System.Diagnostics;
using System.Threading;

namespace CADIS.Solution.Workflow
{
    /// <summary>
    /// Monitors the current process and provides notifications when it exits or exceeds thresholds.
    /// </summary>
    internal class ProcessMonitor : IDisposable
    {
        private readonly Process _process;
        private readonly Timer _timer;
        private readonly int _cpuThreshold;
        private readonly int _memoryThreshold;
        private readonly object _lock = new object();

        private bool _disposed;

        public event Action<string> OnThresholdExceeded;
        public event Action OnProcessExited;

        public ProcessMonitor(int processId, int cpuThreshold, int memoryThreshold, int intervalMs = 5000)
        {
            _process = Process.GetProcessById(processId);
            _process.EnableRaisingEvents = true;
            _process.Exited += Process_Exited;

            _cpuThreshold = cpuThreshold;
            _memoryThreshold = memoryThreshold;

            _timer = new Timer(CheckProcess, null, intervalMs, intervalMs);
        }

        private void Process_Exited(object sender, EventArgs e)
        {
            OnProcessExited?.Invoke();
        }

        private void CheckProcess(object state)
        {
            lock (_lock)
            {
                if (_disposed) return;

                try
                {
                    if (_process.HasExited)
                    {
                        _timer?.Change(Timeout.Infinite, Timeout.Infinite);
                        return;
                    }

                    int cpuUsage = GetCpuUsage();
                    long memoryUsage = _process.WorkingSet64 / (1024 * 1024); // MB

                    if (cpuUsage > _cpuThreshold)
                        OnThresholdExceeded?.Invoke($"CPU usage exceeded: {cpuUsage}%");

                    if (memoryUsage > _memoryThreshold)
                        OnThresholdExceeded?.Invoke($"Memory usage exceeded: {memoryUsage} MB");
                }
                catch (Exception ex)
                {
                    OnThresholdExceeded?.Invoke($"ProcessMonitor error: {ex.Message}");
                }
            }
        }

        private int GetCpuUsage()
        {
            // Placeholder for actual CPU usage calculation
            // Can be replaced with PerformanceCounter or Diagnostics APIs
            return 0;
        }

        public void Dispose()
        {
            lock (_lock)
            {
                if (_disposed) return;
                _disposed = true;

                _timer?.Dispose();
                _process?.Dispose();
            }
        }
    }
}
